/* Author: Jagjot Jhajj
 * 
 * This is a Simon Game built on an Arduino. There should be a Fritzing diagram included in the 
 * file to show how the Arduino should be wired.
 * 
 * The game works as follows:
 * A blue light will flash 3 times to signal the game is starting.
 * Then, a single light will flash. The user must press the switch corresponding to this light.
 * If the correct switch is pressed, then two lights will now flash, one after the other, with 
 * the first light being the same light that flashed on the previous turn. The user must then 
 * press the two corresponging switches, in order. On the nth turn, the first (n-1) lights to flash
 * are the lights that flashed on turn (n-1), and the nth light is randomly generated.
 * 
 * If at any point the user presses an incorrect switch, the game will stop and a red light will quickly flash
 * 10 times to signal that the game is lost. 
 * 
 * If the user has gotten through all of the turns successfully, a green light will quickly flash
 * 10 times to signal that the game is won. 
 * 
 */

//The pins for the LEDs
const int RED_LED = 4;
const int BLUE_LED = 5;
const int GREEN_LED = 3;
const int YELLOW_LED = 2;

//The pins for the switches corresponding to an LED
const int RED_SWITCH = 8;
const int BLUE_SWITCH = 9;
const int GREEN_SWITCH = 7;
const int YELLOW_SWITCH = 6;


//Constants representing a colour, used for the random number generator and comparisons
const int RED = 0;
const int BLUE = 1;
const int GREEN = 2;
const int YELLOW = 3;

//The number of turns the game will go through before ending
const int NUM_TURNS = 5;

//Delay between turns
const int TURN_DELAY = 1000;

//When a light is flashing, the time an LED is on for
const int LIGHT_DELAY = 200;
//When a light is flashing, the time an LED is off for
const int PAUSE_DELAY = 50;

//This delay is for debouncing, to prevent any hardware errors from incorrectly reading a button as pressed
//when it hasn't been. A smaller number can increase hardware error chance while a larger number can make it 
//so that a user has pressed a button but the machine did not read it. I find that 50 is a good number to use
const int DEBOUNCE_DELAY = 50;

//The array holding the pattern
int light_pattern[NUM_TURNS]; 

void setup() {
  Serial.begin(9600);

  //Random seed is generated by noise from the unused analog pin
  randomSeed(analogRead(0));
  
  pinMode(RED_LED, OUTPUT);
  pinMode(BLUE_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);
  pinMode(YELLOW_LED, OUTPUT);

  pinMode(RED_SWITCH, INPUT);
  pinMode(BLUE_SWITCH, INPUT);
  pinMode(GREEN_SWITCH, INPUT);
  pinMode(YELLOW_SWITCH, INPUT);



}

void loop() {

  //Make sure all lights are off at the start
  digitalWrite(RED_LED,LOW);
  digitalWrite(BLUE_LED,LOW);
  digitalWrite(GREEN_LED,LOW);
  digitalWrite(YELLOW_LED,LOW);

  //This loop creates the pattern, using random numbers
  for(int i = 0; i < NUM_TURNS; i++){
    light_pattern[i] = random(0,4);
    
  }

 
  //Flash blue light three times to signal a new game is starting
  for(int i=0; i<3; i++){
    digitalWrite(BLUE_LED,HIGH);
    delay(LIGHT_DELAY);
    digitalWrite(BLUE_LED,LOW);
    delay(PAUSE_DELAY);
  }

  delay(TURN_DELAY);

  //Begin the game
  int turn = 1;
  boolean isWin = true;

  while(turn<=NUM_TURNS && isWin == true){

    //Flash the pattern for this turn
    for(int i = 0; i<turn; i++){
      if(light_pattern[i] == RED){
        digitalWrite(RED_LED,HIGH);
        delay(LIGHT_DELAY);
        digitalWrite(RED_LED,LOW);
        delay(PAUSE_DELAY);
      }

      else if(light_pattern[i] == BLUE){
            digitalWrite(BLUE_LED,HIGH);
            delay(LIGHT_DELAY);
            digitalWrite(BLUE_LED,LOW);
            delay(PAUSE_DELAY);
      }
      
      else if(light_pattern[i] == GREEN){
            digitalWrite(GREEN_LED,HIGH);
            delay(LIGHT_DELAY);
            digitalWrite(GREEN_LED,LOW);
            delay(PAUSE_DELAY);
      }
      else {
            digitalWrite(YELLOW_LED,HIGH);
            delay(LIGHT_DELAY);
            digitalWrite(YELLOW_LED,LOW);
            delay(PAUSE_DELAY);
      }

     
    }

    //This loop reads the input pattern from the user
    for(int i = 0; i<turn; i++){
      
        while(digitalRead(RED_SWITCH) == HIGH ||
              digitalRead(BLUE_SWITCH) == HIGH ||
              digitalRead(GREEN_SWITCH) == HIGH ||
              digitalRead(YELLOW_SWITCH) == HIGH){
               
              delay(10);
              }
              
        
        int input = -1;
        while(input == -1){

            if(digitalRead(RED_SWITCH) == HIGH){
              delay(DEBOUNCE_DELAY);
              if(digitalRead(RED_SWITCH) == HIGH){
                input = RED;
              }
            }

            else if(digitalRead(BLUE_SWITCH) == HIGH){
              delay(DEBOUNCE_DELAY);
              if(digitalRead(BLUE_SWITCH) == HIGH){
                input = BLUE;
              }
            }

            else if(digitalRead(GREEN_SWITCH) == HIGH){
              delay(DEBOUNCE_DELAY);
              if(digitalRead(GREEN_SWITCH) == HIGH){
                input = GREEN;
              }
            }

            else if(digitalRead(YELLOW_SWITCH) == HIGH){
              delay(DEBOUNCE_DELAY);
              if(digitalRead(YELLOW_SWITCH) == HIGH){
                input = YELLOW;
              }
            }
          
        }
        Serial.println(input);
        Serial.println(light_pattern[i]);

        //If the input does not match the pattern, end the game and make the program know its a loss
        if(light_pattern[i] != input){
          isWin = false;
          break;
        }

    }
    turn++;
    delay(TURN_DELAY);
  }

    //Flash a green light 10 times quickly if the user won
    if(isWin == true){
      for(int i=0; i<10; i++){
         digitalWrite(GREEN_LED,HIGH);
         delay(50);
         digitalWrite(GREEN_LED,LOW);
         delay(50);
         }
     }

  //Flash a red light 10 times quickly if the user lost
    else{
      for(int i=0; i<10; i++){
         digitalWrite(RED_LED,HIGH);
         delay(50);
         digitalWrite(RED_LED,LOW);
         delay(50);
         }
    }
    
  delay(TURN_DELAY);
 
  
  

}

